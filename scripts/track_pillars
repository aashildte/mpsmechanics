#!/usr/bin/env python3

"""

Tracks given points for a given data set over time.

Run as

    python track_pillars.py [displacement] [points] [indices]

where displacement is a csv/nd2 file with displacement data, points 
a csv file giving pillar positions + radii, and indices a string
indicating which value to track, "0", "1" or "0 1" (corresponding
to output outlined below):

Output given as (if indicated)
    0) a set of files on the form pt[X]_[Y].csv, saved in where the
       *first* line give number of time steps, number of tracking
       points for that pillar:
           T, N
       (which indicates N uniformly distributed points around (X, Y)
       and then T*N lines of the form
           x y
       which gives the position of the n'th point at time step t;
       all positions first listed for time step 0, then for time
       step 1, etc.
    1) one file called at_maxima.csv, where the first line give
       the maximum indices:
           _, _ , m1, _ , m2, _, m3, _, ...
       and the remaning lines contains the following values:
           original x position of pillar
           original y position of pillar
           x position at index m1
           y position at index m1
           x position at index m2
           y position at index m2 
           ...

All files for numerical output are saved in
    same directory as the displacement file ->
        folder with same name as the displacement file ->
            "track_pillars" ->
                "numerical_output" ->
                    for 0) subfolder named "positions_all_time_steps"
                    for 1) subfolder named "displacement_maxima"

Optionally add -p [indices] or --plot [indices] as an argument to
plot corresponding values. Plots are saved as the numerical output,
but in a subfolder named "plots" instead.

To get scaled output (in micrometers, not "pixel values"), add the
option -s or --scale.

Ã…shild Telle / Simula Research Labratory / 2019

"""

import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

import mpsmechanics as mc


def handle_cl_arguments():
    """
    
    Handles command line arguments for this script, as described
    above and in the README file.

    Returns:
        Filename for displacement data
        Filename for pillar positions data
        List of integers defining which properties to calculate
        List of integers defining which properties to plot
        Boolean value for scaling data to SI units or not

    """
    
    arguments = ((("-p", "--plot"), {"default" : ""}),
            (("-s", "--scale"), {"action" : "store_true"}))

    input_files, calc_properties, args = \
            mc.get_cl_input(arguments)
    
    f_in1, f_in2 = input_files

    assert ((".csv" in f_in1) or (".nd2") in f_in2), \
            "Displacement file must be a csv or nd2 file"
    assert (".csv" in f_in2), \
            "Pillar position file must be a csv file"
  
    return f_in1, f_in2, calc_properties, args.plot, args.scale


def read_pt_file(f_in):
    """

    Reads in values for pillar coordinates + radii.

    Args:
        f_in - Filename

    Returns;
        Numpy array of dimensions P x 3, P being the number of
            points; entries being x, y, radius for all points.

    """

    f = open(f_in, "r")

    lines = f.read().split("\n")[1:]

    if(len(lines[-1])==0):
        lines = lines[:-1]      # ignore last line if empty

    p_values = [[int(x) for x in line.split(",")] \
                        for line in lines]  # or float???

    # using standard radius instead of input; by choice

    r_standard = 1990/664*10       # pixel coords / length * radius
    
    # flip x and y; temporal solution due to two different
    # conventions used. TODO - use same everywhere

    for i in range(len(p_values)):
        x, y, r = p_values[i]
        p_values[i] = [y, x, r_standard]

    p_values = np.array(p_values)

    f.close()

    return p_values


def define_pillars(p_values, N=100):
    """

    Transforms x, y, r values to mesh values.

    Args:
        p_values - list like structure of dimensions P x 3
        N - number of mesh points used

    Returns:
        p_values - mesh points on the circumsphere of the circle
            defined by x, y, z

    """

    P = len(p_values)
    pillars = np.zeros((P, N, 2))

    angles = np.linspace(0, 2*np.pi, N)
    for i in range(P):
        x, y, r = p_values[i]
        for j in range(N):
            pillars[i, j, 0] = x + r*np.cos(angles[j])
            pillars[i, j, 1] = y + r*np.sin(angles[j])

    return pillars


def interpolate_step(xs, ys, org_data):
    """

    Interpolates given data; defines functions based on this.
    First function gives relative displacement; second absolute.

    Args:
        xs - x coordinates
        ys - y coordinates
        org_data - displacement data; X x Y x 2 numpy array

    Returns:
        function f : R2 - R2 - relative
        function g : R2 - R2 - absolute

    """

    Xs = org_data[:,:,0].transpose()
    Ys = org_data[:,:,1].transpose()

    fn_x = interpolate.interp2d(xs, ys, Xs, kind='cubic')
    fn_y = interpolate.interp2d(xs, ys, Ys, kind='cubic')
    
    fn1 = lambda x, y: np.array([fn_x(x, y)[0], fn_y(x, y)[0]])
    fn2 = lambda x, y: np.array([x, y]) + fn1(x, y)
   
    return fn1, fn2


def plot_x_y_coordinates(values, dimensions, t, path):
    """

    Scatter plot of coordinates of each tracking point.

    Args:
        values to be plotted - three-dimensional numpy array,
            last dimensions being 2 (x and y)
        dimensions - picture dimensions, to match output plot
            with actual picture dimensions
        t - timestep, used for identity
        path - save figures here

    """

    scale = 6/dimensions[0]
    dims_scaled = (dimensions[0]*scale, dimensions[1]*scale)

    x_vals = values[:, :, 0].flatten()
    y_vals = values[:, :, 1].flatten()

    fg = plt.figure(t, figsize=dims_scaled)
    t_id = "%04d" % t
    plt.xlim(0, dimensions[0])
    plt.ylim(0, dimensions[1])

    plt.xlabel("$\mu m$")
    plt.ylabel("$\mu m$")

    plt.scatter(x_vals, y_vals, s=0.01)
    plt.savefig(os.path.join(path, "state_" + t_id + ".png"), dpi=1000)

    plt.close()


def write_all_values_to_file(all_values, mpoints, path):
    """

    Output to files: T x N values for each pillar

    Args:
        all_values - numpy array of dimension T x P x N x 2
        coords - midpoints; numpy array of dimension P x 2
        path - save here

    """

    T, P, N = all_values.shape[:3]

    for p in range(P):
        coords = mpoints[p]
        filename = os.path.join(path, "pillar_" + str(coords[0]) + "_" + \
                str(coords[1]) + ".csv")

        f = open(filename, "w")

        f.write(str(T) + ", " + str(N) + "\n")

        for t in range(T):
            for n in range(N):
                x, y = all_values[t, p, n]
                f.write(str(x) + ", " + str(y) + "\n")

        f.close()


def plot_over_time(values, coords, path):
    """

    Plots tracked values over time.

    Args:
        values - numpy array of dimension T x P x 2
        coords - coordinates; (x, y) for P pillars
        path - save figures here

    """
    
    T, P = values.shape[:2]
    fps = 100
    Tmax = T/fps
    ts = np.linspace(0, Tmax, T)
    
    filenames = [os.path.join(path, "all_time_steps_x.png"), \
            os.path.join(path, "all_time_steps_y.png"), \
            os.path.join(path, "all_time_steps_norm.png")]
    titles = ["Displacement over time (x values)", \
              "Displacement over time (y values)", \
              "Displacement over time (l2 norm)"]

    x_values = values[:,:,0]
    y_values = values[:,:,1]

    overall_values = np.zeros((T, P))

    for t in range(T):
        for p in range(P):
            overall_values[t,p] = np.linalg.norm(values[t, p])
    
    d_values = [x_values, y_values, overall_values]

    for i in range(3):
        for p in range(P):
            plt.plot(ts, d_values[i][:,p])

        plt.title(titles[i])
        plt.legend([("(" + str(x[0]) + ", " + str(x[1]) + ")") for x in coords])
        plt.xlabel("Time ($s$)")
        plt.ylabel("Displacement ($\mu m$)")
        plt.savefig(filenames[i], dpi=1000) 
        plt.close()

def write_max_disp_to_file(mid_values, max_indices, coords, path):
    """

    Writes values at maximum displacement to a file.

    Args:
        mid_values - T x P x 2 numpy array
        max_indices - list-alike structure for indices of maxima
        coords - coordinates of midpoints
        path - save file here

    """

    filename = os.path.join(path, "at_maxima.csv")
    f = open(filename, "w")

    max_str = ", ," + ", , ".join([str(m) \
            for m in max_indices]) + "\n"
    f.write(max_str)

    for p in range(len(coords)):
        m_values = [mid_values[m,p] for m in max_indices]

        coords_str = str(coords[p,0]) + ", " + str(coords[p, 1])
        maxima_str = ", ".join([str(m[0]) + ", " + str(m[1]) \
                for m in m_values])

        pos_str = coords_str + ", " + maxima_str + "\n"
        f.write(pos_str)

    f.close()


def track_pillars_over_time(data, pillars, mpoints, dimensions, calc_properties, \
        plt_properties, paths):
    """

    Tracks position of mesh poinds defined for pillars over time, based
    on the displacement data.

    Args:
        data - displacement data, numpy array of size T x X x Y x 2
        pillars - mesh points; on a circle around each middle point
        mpoints - mesh points; center of each pillar
        calc_properties - output values
        plt_properties - plotting values
        paths - save output, plots here

    """

    # some general values

    T, X, Y = data.shape[:3]
    P, N = pillars.shape[:2]

    xs = np.linspace(0, dimensions[0], X)
    ys = np.linspace(0, dimensions[1], Y)
    
    # for tracking pillars
    
    all_values = np.zeros((T, P, N, 2))

    # for force measurements

    mid_values = np.zeros((T, P, 2))
    
    for t in range(T):
        fn1, fn2 = interpolate_step(xs, ys, data[t])
        
        # all points

        for p in range(P):
            for n in range(N):
                all_values[t, p, n] = fn2(pillars[p, n, 0], \
                        pillars[p, n, 1])

        if(0 in plt_properties):
            plot_x_y_coordinates(all_values[t], dimensions, t, paths["plt_all"])

        # midpoints
        for p in range(P):
            mean = 0
            for n in range(N):
                mean += fn1(*pillars[p, n])
            mean /= N
            mid_values[t, p] = mean

    # save values

    if (0 in calc_properties):
        write_all_values_to_file(all_values, mpoints, paths["num_all"])

    # find values at maximum displacement
    
    if(1 in calc_properties):
        movement = mc.calc_filter(data, 1E-10)
        max_indices = mc.calc_beat_maxima_2D(data, movement)
        
        if(1 in plt_properties):
            plot_over_time(mid_values, mpoints, paths["plt_max"])

        if(len(max_indices)==0):
            print("No maxima found for this data set.")
        else:
            write_max_disp_to_file(mid_values, max_indices, mpoints, \
                paths["num_max"])
    


if __name__ == "__main__":
    
    # command line arguments

    f_in1, f_in2, calc_properties, plt_properties, scale_data = \
            handle_cl_arguments()

    # some default values --- TODO get from metadata instead

    dimensions_um = np.array((664.30, 381.55))  # um
    dimensions = np.array((1990, 958))          # pixels??

    # displacement data

    data = mc.read_file(f_in1)
    _, _, X, _ = data.shape

    alpha = 0.75
    N_diff = 5
    data = mc.do_diffusion(data, alpha, N_diff, over_time=True)

    # points of interest

    pillars_mpoints = read_pt_file(f_in2)
    pillars = define_pillars(pillars_mpoints)

    # scale data
    
    if(scale_data):
        scale = dimensions_um[0]/dimensions[0]
        
        print("Scale conversion: pixels (x, y, r) -> um (x, y, r)")

        for p in pillars_mpoints:
            print("(%d, %d, %d) -> (%d, %d, %d)" % (p[0], p[1], p[2], \
                    int(scale*p[0]), int(scale*p[1]), int(scale*p[2])))
        
        data = scale*data
        pillars_mpoints = np.array([(int(scale*x), int(scale*y)) \
                for (x, y, _) in pillars_mpoints])
        pillars = scale*pillars
    else:
        scale = 1

    # setup for saving things

    path, idt, ext = mc.get_input_properties(f_in1)
    
    print("Tracking pillars for data set: ", idt)

    path_num, path_plots = \
            mc.make_default_structure(path, "track_pillars", idt)

    paths = []

    for p in [path_num, path_plots]:
        for a in ["positions_all_time_step", "displacement_maxima"]:
            pt = os.path.join(p, a)
            mc.make_dir_structure(pt)
            paths.append(pt)

    paths_dir = {}
    paths_dir["num_all"] = paths[0]
    paths_dir["num_max"] = paths[1]
    paths_dir["plt_all"] = paths[2]
    paths_dir["plt_max"] = paths[3]

    # track values
    track_pillars_over_time(data, pillars, pillars_mpoints, dimensions_um, \
            calc_properties, plt_properties, paths_dir)

    print("Pillar tracking for " + idt + " finished:")
    print(" * Output saved in '" + path_num + "'")

    if(len(plt_properties)>0):
        print(" * Specified plots saved in '" + path_plots + "'")
