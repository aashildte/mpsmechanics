#!/usr/bin/env python3

"""

Tracks given points for a given data set over time.

Run as

    python track_pillars.py [displacement] [points] [indices]

where displacement is a csv/nd2 file with displacement data, points 
a csv file giving pillar positions + radii, and indices a string
indicating which value to track, "0", "1" or "0 1" (corresponding
to output outlined below):

Output given as (if indicated)
    0) a set of files on the form pt[X]_[Y].csv, saved in where the
       *first* line give number of time steps, number of tracking
       points for that pillar:
           T, N
       (which indicates N uniformly distributed points around (X, Y)
       and then T*N lines of the form
           x y
       which gives the position of the n'th point at time step t;
       all positions first listed for time step 0, then for time
       step 1, etc.
    1) one file called at_maxima.csv, where the first line give
       the maximum indices:
           _, _ , m1, _ , m2, _, m3, _, ...
       and the remaning lines contains the following values:
           original x position of pillar
           original y position of pillar
           x position at index m1
           y position at index m1
           x position at index m2
           y position at index m2 
           ...

All files for numerical output are saved in
    same directory as the displacement file ->
        folder with same name as the displacement file ->
            "track_pillars" ->
                "numerical_output" ->
                    for 0) subfolder named "positions_all_time_steps"
                    for 1) subfolder named "displacement_maxima"

Optionally add -p [indices] as an argument to plot corresponding
values. Plots are saved as the numerical output, but in a subfolder
named "plots" instead.

Ã…shild Telle / Simula Research Labratory / 2019

"""

import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

import mpsmechanics as mc

def read_pt_file(f_in):
    """

    Reads in values for pillar coordinates + radii.

    Arguments:
        f_in - Filename

    Returns;
        Numpy array of dimensions P x 3, P being the number of
            points; entries being x, y, radius for all points.

    """

    f = open(f_in, "r")

    lines = f.read().split("\n")[1:]

    if(len(lines[-1])==0):
        lines = lines[:-1]      # ignore last line if empty

    p_values = [[int(x) for x in line.split(",")] \
                        for line in lines]  # or float???

    # using standard radius instead of input; by choice

    r_standard = 1990/664*10       # pixel coords / length * radius
    
    # flip x and y; temporal solution due to two different
    # conventions used. TODO - use same everywhere

    for i in range(len(p_values)):
        x, y, r = p_values[i]
        p_values[i] = [y, x, r_standard]

    p_values = np.array(p_values)

    f.close()

    return p_values


def define_pillars(p_values, N=100):
    """

    Transforms x, y, r values to mesh values.

    Arguments:
        p_values - list like structure of dimensions P x 3
        N - number of mesh points used

    Returns:
        p_values - mesh points on the circumsphere of the circle
            defined by x, y, z

    """

    P = len(p_values)
    pillars = np.zeros((P, N, 2))

    angles = np.linspace(0, 2*np.pi, N)
    for i in range(P):
        x, y, r = p_values[i]
        for j in range(N):
            pillars[i, j, 0] = x + r*np.cos(angles[j])
            pillars[i, j, 1] = y + r*np.sin(angles[j])

    return pillars


def interpolate_step(xs, ys, org_data):
    """

    Interpolates given data; defines functions based on this.
    First function gives relative displacement; second absolute.

    Arguments:
        xs - x coordinates
        ys - y coordinates
        org_data - displacement data; X x Y x 2 numpy array

    Returns:
        function f : R2 - R2 - relative
        function g : R2 - R2 - absolute

    """

    Xs = org_data[:,:,0].transpose()
    Ys = org_data[:,:,1].transpose()

    fn_x = interpolate.interp2d(xs, ys, Xs, kind='cubic')
    fn_y = interpolate.interp2d(xs, ys, Ys, kind='cubic')
    
    fn1 = lambda x, y: np.array([fn_x(x, y)[0], fn_y(x, y)[0]])
    fn2 = lambda x, y: np.array([x, y]) + fn1(x, y)
   
    return fn1, fn2


def plot_x_y_coordinates(values, dimensions, t, path):
    """

    Scatter plot of coordinates of each tracking point.

    Arguments:
        values to be plotted - three-dimensional numpy array,
            last dimensions being 2 (x and y)
        dimensions - picture dimensions, to match output plot
            with actual picture dimensions
        t - timestep, used for identity
        path - save figures here

    """

    scale = 6/dimensions[0]
    dims_scaled = (dimensions[0]*scale, dimensions[1]*scale)

    x_vals = values[:, :, 0].flatten()
    y_vals = values[:, :, 1].flatten()

    fg = plt.figure(t, figsize=dims_scaled)
    t_id = "%04d" % t
    plt.xlim(0, dimensions[0])
    plt.ylim(0, dimensions[1])

    plt.xlabel("$\mu m$")
    plt.ylabel("$\mu m$")

    plt.scatter(x_vals, y_vals, s=0.01)
    plt.savefig(os.path.join(path, "state_" + t_id + ".png"), dpi=1000)

    plt.close()


def write_all_values_to_file(all_values, coords, path):
    """

    Output to files: T x N values for each pillar

    Arguments:
        all_values - numpy array of dimension T x P x N x 2
        coords - midpoints; numpy array of dimension P x 2
        path - save here

    """

    T, P, N = all_values.shape[:3]

    for p in range(P):
        coords = mpoints[p]
        filename = os.path.join(path, "pillar_" + str(coords[0]) + "_" + \
                str(coords[1]) + ".csv")

        f = open(filename, "w")

        f.write(str(T) + ", " + str(N) + "\n")

        for t in range(T):
            for n in range(N):
                x, y = all_values[t, p, n]
                f.write(str(x) + ", " + str(y) + "\n")

        f.close()


def plot_over_time(values, coords, path):
    """

    Plots tracked values over time.

    Arguments:
        values - numpy array of dimension T x P x 2
        coords - coordinates; (x, y) for P pillars
        path - save figures here

    """
    
    T, P = values.shape[:2]
    fps = 100
    Tmax = T/fps
    ts = np.linspace(0, Tmax, T)
    
    filenames = [os.path.join(path, "all_time_steps_x.png"), \
            os.path.join(path, "all_time_steps_y.png")]
    titles = ["Displacement over time (x values)", \
              "Displacement over time (y values)"]

    for i in range(2):
        for p in range(P):
            plt.plot(ts, values[:,p,i])

        plt.legend([("(" + str(x[0]) + ", " + str(x[1]) + ")") for x in coords])
        plt.xlabel("Time ($$)")
        plt.ylabel("Displacement ($\mu m$)")
        plt.savefig(filenames[i], dpi=1000) 
        plt.close()


def write_max_disp_to_file(mid_values, max_indices, coords, path):
    """

    Writes values at maximum displacement to a file.

    Arguments:
        mid_values - T x P x 2 numpy array
        max_indices - list alike structure for indices of maxima
        coords - coordinates of midpoints
        path - save file here

    """

    filename = os.path.join(path, "at_maxima.csv")
    f = open(filename, "w")

    max_str = ", ," + ", , ".join([str(m) \
            for m in max_indices]) + "\n"
    f.write(max_str)
    
    for p in range(len(coords)):
        m_values = [mid_values[m,p] for m in max_indices]

        pos_str = str(coords[p,0]) + ", " + str(coords[p,1]) + \
                ", " + ", ".join([str(m[0]) + ", " + str(m[1]) \
                for m in m_values]) + "\n"

        f.write(pos_str)

    f.close()


def track_pillars_over_time(data, pillars, mpoints, dimensions, calc_ids, \
        plt_ids, paths):
    """

    Tracks position of mesh poinds defined for pillars over time, based
    on the displacement data.

    Arguments:
        data - displacement data, numpy array of size T x X x Y x 2
        pillars - mesh points; on a circle around each middle point
        mpoints - mesh points; center of each pillar
        calc_ids - output values
        plt_ids - plotting values
        paths - save output, plots here

    """

    # some general values

    T, X, Y = data.shape[:3]
    P, N = pillars.shape[:2]

    xs = np.linspace(0, dimensions[0], X)
    ys = np.linspace(0, dimensions[1], Y)
    
    # for tracking pillars
    
    all_values = np.zeros((T, P, N, 2))

    # for force measurements

    mid_values = np.zeros((T, P, 2))
    
    for t in range(T):

        fn1, fn2 = interpolate_step(xs, ys, data[t])
        
        # all points

        for p in range(P):
            for n in range(N):
                all_values[t, p, n] = fn2(pillars[p, n, 0], \
                        pillars[p, n, 1])

        if(0 in plt_ids):
            plot_x_y_coordinates(all_values[t], dimensions, t, paths["plt_all"])

        # midpoints
        for p in range(P):
            mean = 0
            for n in range(N):
                mean += fn1(*pillars[p, n])
            mean /= N
            mid_values[t, p] = mean

    # save values

    if (0 in calc_ids):
        write_all_values_to_file(all_values, mpoints, paths["num_all"])

    # find values at maximum displacement
    
    if(1 in calc_ids):
        movement = mc.calc_filter(data, 1E-10)
        max_indices = mc.calc_beat_maxima_2D(data, movement)

        write_max_disp_to_file(mid_values, max_indices, mpoints, \
                paths["num_max"])
    
        if(1 in plt_ids):
            plot_over_time(mid_values, mpoints, paths["plt_max"])

if __name__ == "__main__":
    
    input_files, calc_ids, plt_ids, _ = mc.get_cl_input()
    f_in1, f_in2 = input_files

    dimensions_um = np.array((664.30, 381.55))  # um
    dimensions = np.array((1990, 958))        # pixels??

    data = mc.read_file(f_in1)[:5]
    _, _, X, _ = data.shape

    # averaging process - adjustable values
    alpha = 0.75
    N_diff = 5
    data = mc.do_diffusion(data, alpha, N_diff, over_time=True)

    # points of interest

    points = read_pt_file(f_in2)
    pillars = define_pillars(points)

    # scale data

    scale = dimensions_um[0]/dimensions[0]
    data = scale*data
    pillars = scale*pillars

    # setup for saving things

    path, idt, ext = mc.get_input_properties(f_in1)
    
    print("Tracking pillars for data set: ", idt)

    path_num, path_plots = \
            mc.make_default_structure(path, "track_pillars", idt)

    paths = []

    for p in [path_num, path_plots]:
        for a in ["positions_all_time_step", "displacement_maxima"]:
            pt = os.path.join(p, a)
            mc.make_dir_structure(pt)
            paths.append(pt)

    paths_dir = {}
    paths_dir["num_all"] = paths[0]
    paths_dir["num_max"] = paths[1]
    paths_dir["plt_all"] = paths[2]
    paths_dir["plt_max"] = paths[3]

    # track values

    mpoints = np.array([(x, y) for (x, y, r) in points])

    track_pillars_over_time(data, pillars, mpoints, dimensions_um, \
            calc_ids, plt_ids, paths_dir)

    print("Pillar tracking for " + idt + " finished:")
    print(" * Output saved in '" + path_num + "'")

    if(len(plt_ids)>0):
        print(" * Specified plots saved in '" + path_plots + "'")
